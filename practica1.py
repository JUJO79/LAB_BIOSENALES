# -*- coding: utf-8 -*-
"""Practica1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/11f_mv0OIO8OSJnCOVyq5Y8icElMgixq-
"""

#Hecho por Juan Jose Lopez Cuadros

# Práctica 1
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

# a) Para crear los vectores se utiliza np.array()
Vector_a = np.array([3.1, 1, -0.5, -3.2, 6])
Vector_b = np.array([1, 3, 2.2, 5.1, 1])
print("Vector a:",Vector_a)
print("Vector b:",Vector_b)

# b) Para poder realizar la multiplicación escalar entre los dos vectores creados anteriormente ambos deben ser de tipo array
# y tener las dimensiones compatibles, se utiliza np.dot()
Mult_escalar = np.dot(Vector_a, Vector_b)
print("Multiplicación Escalar a.b:",Mult_escalar)

# c) Para la multiplicación punto a punto entre los vectores a y b se utiliza np.multiply()
Mult_punto = np.multiply(Vector_a, Vector_b)
print("Multiplicación Punto a Punto a*b:",Mult_punto)

# d) Para crear la matriz se vuelve a utilizar np.array()
Matriz = np.array([[2, -1, 3], [4,1.5,-2.5], [7.3, -0.9, 0.2]])
print("\nMatriz:\n",Matriz)

# e) Para la matriz transpuesta se utiliza .T
Mat_Transpuesta = Matriz.T
print("\nMatriz Transpuesta:\n", Mat_Transpuesta)

# f) Consulta de funciones:
# Numpy ones: Crea una matriz de unos, Ej: matriz 3x3 de unos
print("\nMatriz de unos:\n", np.ones((3,3)))
# Numpy Round: Redondea al decimal más cercano
print("\nRedondeo de 3:\n", np.round(2.6))
# Numpy Ceil : Redondea hacia arriba al entero superior
print("\nRedondeo hacia arriba de 2.1:\n", np.ceil(2.1))
# Numpy floor: Redondea hacia abajo al entero inferior
print("\nRedondeo hacia abajo de 2.9:\n", np.floor(2.9))

# g) Para acceder al valor de la primera fila de la tercera columna se hacen uso de los indices
print("\nValor primera 1era, 3era columna:\n", Matriz[0,2])

# h) Para obtener la segunda fila se utilizan nuevamente los indices:
print("\n2da fila de la matriz:\n", Matriz[1])

# i) Para conocer el tamaño de la matriz se utiliza el comando shape:
print("\nTamaño de la matriz:\n", Matriz.shape,"\n")

# j) Para crear la señal senoidal se hace uso de las funciones de numpy np.arange() para el intervalo y np.sin() para la senoidal
n = np.arange(0,101)
y = np.sin(np.pi*0.12*n)

# k) Para crear la otra senoidal se hace lo mismo que en el anterior caso
y2 = np.cos(np.pi*2*0.03*n)

# l) Para crear una tercera y cuarta señal se suman y multiplican las dos anteriormente creadas con los caraccteres apropiados
s = y + y2
t = y*y2

# m) Para graficar y Y y2 se utiliza matplotlib
# se crea la figura
plt.figure(figsize=(10, 5))
# Para graficar ambas señales con colores y etiquetas se utiliza label
# 'label' define el texto que aparecerá en la leyenda
plt.stem(n, y, linefmt='blue', label='Señal y[n]')
plt.stem(n, y2, linefmt='red', label='Señal y2[n]')
# Para añadir nombre a los ejes se utiliza xlabel y ylabel, para el nombre de la gráfica se utiliza title, se utiliza legend para mostrar la leyenda
plt.title(' Señales y[n] y y2[n]')
plt.xlabel('n')
plt.ylabel('Amplitud')
plt.legend()
plt.show()

# n) Se hace nuevamente lo hecho anteriormente pero ahora para las señales s[n] y t[n]
plt.figure(figsize=(10, 5))
plt.stem(n, s, linefmt='green', label='Señal s[n]')
plt.stem(n, t, linefmt='purple', label='Señal t[n]')
plt.title(' Señales s[n] y t[n]')
plt.xlabel('n')
plt.ylabel('Amplitud')
plt.legend()
plt.show()

# PANDAS
# 1)
def estadisticas_notas(diccionario_notas):
    # Se pasa el diccionario a una serie de pandas
    serie_notas = pd.Series(diccionario_notas)

    # Se calculan los estadisticos
    estadisticos = pd.Series({
        'Nota Mínima': serie_notas.min(),
        'Nota Máxima': serie_notas.max(),
        'Media': serie_notas.mean(),
        'Desviación Típica': serie_notas.std()
    })
    return estadisticos

# Ejemplo:
print("\nEstadisticas de notas:\n")
notas_curso = {'Ana': 4.5, 'Luis': 3.2, 'Marta': 4.8, 'Juan': 2.5}
print(estadisticas_notas(notas_curso))

# 2) Cálculo IMC
# a) Primero cargamos los datos del archivo excel con pandas y se utiliza el separador por defecto ; para que se lean correctamentr
df = pd.read_csv("datos.csv", sep=';')

# b) Para conocer la estructura de los datos se utiliza .head() para las primera filas y obtener asi el nombre de las columnas y .tail() para las ultimas filas
print("\nPrimeras filas:\n", df.head())
print("\nÚltimas filas:\n", df.tail())

# c) Para borrar la columna "Unnamed: 0" se utiliza .drop()
df = df.drop(columns=['Unnamed: 0'], errors='ignore')


# d) Se calcula el imc con la formula dada, la altura se divide por 100 para pasar de cm a metros
df['BMI'] = df['Weight'] / (df['Height'] / 100)**2

# f) Para categorizar se utiliza una función que recibe el IMC calculado anteriormente
def categorizar_imc(imc):
    if imc < 18.5:
        return "Bajo peso"
    elif 18.5 <= imc <= 24.9:
        return "Normal"
    elif 25 <= imc <= 29.9:
        return "Sobrepeso"
    else:
        return "Obesidad"

df['Category'] = df['BMI'].apply(categorizar_imc)

# Mostrar resultado final
print("\nDataFrame con IMC calculado:")
print(df)